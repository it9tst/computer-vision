// main.cpp : Questo file contiene la funzione 'main', in cui inizia e termina l'esecuzione del programma.

//std c/c++
#include <windows.h>
#include <iostream>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <chrono>

//GoSdk
#include <GoSdk/GoSdk.h>
#include <stdio.h>
#include <stdlib.h>

//OpenCV
#include <opencv2/opencv.hpp>

//PCL visualiser
#include <pcl/point_types.h>
#include <pcl/io/pcd_io.h>
#include <pcl/io/ply_io.h>
#include <pcl/visualization/pcl_visualizer.h>


#include "Gocator.h"

//constants
#define SENSOR_IP "192.168.1.151"
#define RECEIVE_TIMEOUT 20000000
#define INVALID_RANGE_16BIT     ((signed short)0x8000)          // gocator transmits range data as 16-bit signed integers. 0x8000 signifies invalid range data.
#define DOUBLE_MAX              ((k64f)1.7976931348623157e+308) // 64-bit double - largest positive value.
#define INVALID_RANGE_DOUBLE    ((k64f)-DOUBLE_MAX)             // floating point value to represent invalid range data.

#define NM_TO_MM(VALUE) (((k64f)(VALUE))/1000000.0)
#define UM_TO_MM(VALUE) (((k64f)(VALUE))/1000.0)

typedef struct {
	double x;   // x-coordinate in engineering units (mm) - position along laser line
	double y;   // y-coordinate in engineering units (mm) - position along the direction of travel
	double z;   // z-coordinate in engineering units (mm) - height (at the given x position)
	unsigned char intensity;
} ProfilePoint;

//main
int main(int argc, char** argv) {
	kStatus status;
	kAssembly api = kNULL;
	GoSystem system = kNULL;
	GoSensor sensor = kNULL;
	kIpAddress ipAddress;
	kChar model_name[50];
	GoDataSet dataset = kNULL;
	GoStamp* stamp = kNULL;
	GoProfilePositionX positionX = kNULL;
	GoDataMsg dataObj;
	GoMeasurementData* measurementData = kNULL;
	unsigned int i, j, k;

	//Hello message
	std::cout << "Gocator example running" << std::endl;

	// construct Gocator API Library
	if ((status = GoSdk_Construct(&api)) != kOK) {
		std::cout << "Error: GoSdk_Construct: " << status << std::endl;
		return -1;
	}

	// construct GoSystem object
	if ((status = GoSystem_Construct(&system, kNULL)) != kOK) {
		std::cout << "Error: GoSystem_Construct: " << status << std::endl;
		return -1;
	}

	// obtain GoSensor object by sensor IP address
	kIpAddress_Parse(&ipAddress, SENSOR_IP);
	if ((status = GoSystem_FindSensorByIpAddress(system, &ipAddress, &sensor)) != kOK) {
		std::cout << "Error: GoSystem_FindSensorByIpAddress: " << status << std::endl;
		return -1;
	}

	// create connection to GoSensor object
	if ((status = GoSensor_Connect(sensor)) != kOK) {
		std::cout << "Error: GoSensor_Connect: " << status << std::endl;
		std::cout
			<< "error code defined in kStatus :			 \n"
			<< "#define kERROR_STATE               (-1000)\n"
			<< "#define kERROR_NOT_FOUND           (-999) \n"
			<< "#define kERROR_COMMAND             (-998) \n"
			<< "#define kERROR_PARAMETER           (-997) \n"
			<< "#define kERROR_UNIMPLEMENTED       (-996) \n"
			<< "#define kERROR_MEMORY              (-994) \n"
			<< "#define kERROR_TIMEOUT             (-993) \n"
			<< "#define kERROR_INCOMPLETE          (-992) \n"
			<< "#define kERROR_STREAM              (-991) \n"
			<< "#define kERROR_CLOSED              (-990) \n"
			<< "#define kERROR_VERSION             (-989) \n"
			<< "#define kERROR_ABORT               (-988) \n"
			<< "#define kERROR_ALREADY_EXISTS      (-987) \n"
			<< "#define kERROR_NETWORK             (-986) \n"
			<< "#define kERROR_HEAP                (-985) \n"
			<< "#define kERROR_FORMAT              (-984) \n"
			<< "#define kERROR_READ_ONLY           (-983) \n"
			<< "#define kERROR_WRITE_ONLY          (-982) \n"
			<< "#define kERROR_BUSY                (-981) \n"
			<< "#define kERROR_CONFLICT            (-980) \n"
			<< "#define kERROR_OS                  (-979) \n"
			<< "#define kERROR_DEVICE              (-978) \n"
			<< "#define kERROR_FULL                (-977) \n"
			<< "#define kERROR_IN_PROGRESS         (-976) \n"
			<< "#define kERROR                     (0)	 \n"
			<< "#define kOK                        (1) 	 \n"
			<< std::endl;
		return -1;
	}

	// enable sensor data channel
	if ((status = GoSystem_EnableData(system, kTRUE)) != kOK) {
		std::cout << "Error: GoSensor_EnableData: " << status << std::endl;
		return -1;
	}

	//gets the sensor model
	if ((status = GoSensor_Model(sensor, model_name, 50)) != kOK) {
		std::cout << "Error: GoSensor_Model: " << status << std::endl;
		return -1;
	}

	//prints sensor info
	std::cout << "Connected to Sensor: " << std::endl;
	std::cout << "\tModel: \t" << model_name << std::endl;
	std::cout << "\tIP: \t" << SENSOR_IP << std::endl;
	std::cout << "\tSN: \t" << GoSensor_Id(sensor) << std::endl;
	std::cout << "\tState: \t" << GoSensor_State(sensor) << std::endl;
	
	// start Gocator sensor
	if ((status = GoSystem_Start(system)) != kOK) {
		std::cout << "Error: GoSystem_Start: " << status << std::endl;
		return -1;
	}

	int count = 0;
	while (cv::waitKey(10) != 'q') {

		//Get data
		std::cout << "\n\nSensor is running ..." << std::endl;

		if (GoSystem_ReceiveData(system, &dataset, RECEIVE_TIMEOUT) == kOK) {
			short int* height_map_memory = NULL;
			unsigned char* intensity_image_memory = NULL;
			ProfilePoint** surfaceBuffer = NULL;
			k32u surfaceBufferHeight = 0;

			std::cout << "************************* Start of GoSystem_ReceiveData *************************" << std::endl;
			std::cout << "\nData message received: " << std::endl;
			std::cout << "Dataset total count: " << GoDataSet_Count(dataset) << "\n" << std::endl;

			// each result can have multiple data items
			// loop through all items in result message
			for (i = 0; i < GoDataSet_Count(dataset); ++i) {
				std::cout << "\n\nDataset index count: " << i << std::endl;
				dataObj = GoDataSet_At(dataset, i);

				switch (GoDataMsg_Type(dataObj)) {

					case GO_DATA_MESSAGE_TYPE_STAMP:
					{
						GoStampMsg stampMsg = dataObj;
						std::cout << "Stamp Message batch count: " << GoStampMsg_Count(stampMsg) << std::endl;
						for (j = 0; j < GoStampMsg_Count(stampMsg); ++j) {
							stamp = GoStampMsg_At(stampMsg, j);
							std::cout << "  Timestamp: " << stamp->timestamp << std::endl;
							std::cout << "  Encoder: " << stamp->encoder << std::endl;
							std::cout << "  Frame index: " << stamp->frameIndex << std::endl;
						}
					}
					break;

					case GO_DATA_MESSAGE_TYPE_MEASUREMENT:
					{
						GoMeasurementMsg measurementMsg = dataObj;
						std::cout << "Measurement Message batch count: " << GoMeasurementMsg_Count(measurementMsg) << std::endl;
						for (k = 0; k < GoMeasurementMsg_Count(measurementMsg); ++k) {
							measurementData = GoMeasurementMsg_At(measurementMsg, k);
							std::cout << "Measurement ID: " << GoMeasurementMsg_Id(measurementMsg) << std::endl;
							std::cout << "Measurement Value: " << measurementData->value << std::endl;
							std::cout << "Measurement Decision: " << measurementData->decision << std::endl;
						}
					}
					break;

					case GO_DATA_MESSAGE_TYPE_SURFACE:
					{
						//point cloud
						pcl::PointCloud<pcl::PointXYZ> _p_cloud;

						//cast to GoSurfaceMsg
						GoSurfaceMsg surfaceMsg = dataObj;

						//Get general data of the surface
						unsigned int row_count = GoSurfaceMsg_Length(surfaceMsg);
						unsigned int width = GoSurfaceMsg_Width(surfaceMsg);
						unsigned int exposure = GoSurfaceMsg_Exposure(surfaceMsg);

						//get offsets and resolutions
						double xResolution = NM_TO_MM(GoSurfaceMsg_XResolution(surfaceMsg));
						double yResolution = NM_TO_MM(GoSurfaceMsg_YResolution(surfaceMsg));
						double zResolution = NM_TO_MM(GoSurfaceMsg_ZResolution(surfaceMsg));
						double xOffset = UM_TO_MM(GoSurfaceMsg_XOffset(surfaceMsg));
						double yOffset = UM_TO_MM(GoSurfaceMsg_YOffset(surfaceMsg));
						double zOffset = UM_TO_MM(GoSurfaceMsg_ZOffset(surfaceMsg));

						//Print raw cloud metadata
						std::cout << "Surface Message" << std::endl;
						std::cout << "\tLength: " << row_count << std::endl;
						std::cout << "\tWidth: " << width << std::endl;
						std::cout << "\tExposure: " << exposure << std::endl;
						std::cout << "\txResolution: " << xResolution << std::endl;
						std::cout << "\tyResolution: " << yResolution << std::endl;
						std::cout << "\tzResolution: " << zResolution << std::endl;
						std::cout << "\txOffset: " << xOffset << std::endl;
						std::cout << "\tyOffset: " << yOffset << std::endl;
						std::cout << "\tzOffset: " << zOffset << std::endl;


						//resize the point cloud
						_p_cloud.height = row_count;
						_p_cloud.width = width;
						_p_cloud.resize(row_count * width);

						//run over all rows
						for (unsigned int ii = 0; ii < row_count; ii++) {
							//get the pointer to row
							short* data = GoSurfaceMsg_RowAt(surfaceMsg, ii);

							//run over the width of row ii
							for (unsigned int jj = 0; jj < width; jj++) {
								//set xy in meters. x component inverted to fulfill right-handed frame (Gocator is left-handed!)
								_p_cloud.points.at(ii * width + jj).x = -0.001 * (xOffset + xResolution * jj);
								_p_cloud.points.at(ii * width + jj).y = 0.001 * (yOffset + yResolution * ii);

								//set z  in meters.
								if (data[jj] != INVALID_RANGE_16BIT)
									_p_cloud.points.at(ii * width + jj).z = 0.001 * (zOffset + zResolution * data[jj]);
								else
									_p_cloud.points.at(ii * width + jj).z = 0.001 * (INVALID_RANGE_DOUBLE);
							}
						}

						pcl::io::savePCDFileASCII("PointCloudGocator" + std::to_string(count) + ".pcd", _p_cloud);
						//pcl::io::savePLYFileASCII("PointCloudGocator" + std::to_string(count) + ".ply", _p_cloud);
						count++;
					}
					break;
				}
			}
			GoDestroy(dataset);
			std::cout << "************************* End of GoSystem_ReceiveData ***************************\n\n" << std::endl;
		} else {
			printf("Error: No data received during the waiting period\n");
		}
	}

	//sleep for a while
	Sleep(5);

	// stop Gocator sensor
	if ((status = GoSystem_Stop(system)) != kOK) {
		std::cout << "Error: GoSystem_Stop: " << status << std::endl;
		return -1;
	}

	// destroy handles
	GoDestroy(system);
	GoDestroy(api);

	//bye bye message
	std::cout << "Program finished !" << status << std::endl;
	return 1;
}